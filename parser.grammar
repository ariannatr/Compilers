Package compiler;


Helpers
  unicode_input_character = [0..0xffff];
  sp = ' ';
  lf = 0x000a;
  cr = 0x000d;
  ff = 0x000c;
  ht = 0x0009; 
  line_terminator = lf | cr | cr lf;
  input_comment = [unicode_input_character - '$'];
  input_character = [unicode_input_character - [cr + lf ]];
  white_space = (sp | ht | ff | line_terminator)*;
  digit = ['0' .. '9'];
  sq=0x0027;
  nn=digit | ['a'..'f'] |['A'..'F'];
  escape_sequence = '\t' | '\n' | '\r' | '\0' | '\\' | '\' sq | '\"' | '\x'nn ;
  letter=['a' .. 'z'] | ['A' .. 'Z'] ;
  char_or_digit =letter | digit |'_';
  char_literal = ' ' | '!' | '"' | '#' | '$' | '%' | '&' | '(' | ')' 
        | '*' | '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' | '=' | '>' 
        | '?' | '@' | '[' | ']' | '^' | '_' | '`' | '{' | '|' | '}' | '~' | letter | digit | escape_sequence;

Tokens
  white_space = white_space;
  escape_sequence=escape_sequence;
 
  and	= 'and';
  char	= 'char';
  div	= 'div';
  do	= 'do';
  else 	= 'else';
  fun 	= 'fun';
  if 	= 'if';
  int 	= 'int';
  mod 	= 'mod';
  not 	= 'not';
  nothing= 'nothing';
  or	= 'or';
  ref	= 'ref';
  return= 'return';
  then	= 'then';
  var	= 'var';
  while = 'while';

  //operators

  minus = '-';
  plus	= '+';
  star	= '*';
  hashtag = '#';
  gt	= '>';
  gteq 	= '>=';
  lt 	= '<';
  lteq 	= '<=';
  slash = '/';
  assign= '=';
  neq 	= '<>';
  
  // separators

  comma = ',';
  l_bkt = '[';
  l_brc = '{';
  l_par = '(';
  r_bkt = ']';
  r_brc = '}';
  r_par = ')';
  semi  = ';';
  colon = ':';
  arrow = '<-';  

  variable = letter char_or_digit*;

  integer=digit+;
  string_lit ='"'char_literal*'"';
  const_char=sq char_literal sq;

  //comments

  end_of_line_comment = '$' input_comment input_character* line_terminator?;
  big_comment = '$$' input_comment* ('$' (input_comment+))* '$$';
Ignored Tokens
  white_space,
  end_of_line_comment,
  big_comment;
  

Productions

programm = 
	{programm}line+;

line=
	{line}func_def;

func_def = 
	{func_def}header local_def* block;

header =
	{header} fun  variable l_par fpar_def r_par colon ret_type;

fpar_def =
    {fpar_def1} ref? variable colon type fpar_def|
    {fpar_def2} ref? variable comma fpar_def |
    {fpar_def3} ref? variable colon type comma fpar_def |
    {fpar_def4} semi fpar_def |
    {fpar_def5} ;

fpar_type =
	{fpar_typr}data_type [array_def]:array_num*;

data_type = 
	{int} int | {char} char;

type = 
	{type}data_type array_num*;

ret_type = 
	{data_typ} data_type |{nothing} nothing;


array_num =
	{array_nu} l_bkt integer? r_bkt;

local_def = 
	{func_de} func_def | 
	{func_dec} func_decl|
	{var_def} var_def;

extra_variables = 
	{extra_variable}comma variable;

var_def =
	{var_def}var variable [variables]:extra_variables* colon type semi;

func_decl =
 {func_decl}header semi;

stmt =
	{empty} semi |
	{expr} l_value arrow expr semi |
	{block} block |
	{func_call} func_call semi| 
	{if_statement} if_statement|
	{while_statement} while_statement|
	{return} return expr? semi;

block = 
	{block}l_brc [statements]:stmt* r_brc;

if_statement=
	{no_else}if cond then [then_stmt]:stmt |
	{with_else}if cond then [then_stmt]:stmt_with_else else [else_stmt]:stmt;

stmt_with_else = {noop} semi
    | {if} if_else_stmt
    |{return_else} return expr? semi
    | {block_else} block;

if_else_stmt = 
 	{if_else}if cond then [then_stmt]:stmt_with_else 
 	else [else_stmt]:stmt_with_else;

 while_statement =
 	{while_statement}while cond do stmt;

func_call = 
{func_call} variable l_par fun_param r_par;

fun_param = 
	{one} expr |
	{many} fun_param comma expr|
	{none} ;


cond = 
	//{cond_block} l_par cond r_par | 
	{not_cond} not cond | 
	{cond_expr} condition_and_expr;

condition_and_expr=
 	{comp_eq_expr} comp_eq_expr|
 	{comp_or} condition_and_expr or comp_eq_expr|
 	{comp_and} condition_and_expr and comp_eq_expr;

comp_eq_expr=
	{comp_eq_rel} comp_rel_expr|
	{comp_eq} comp_eq_expr compare_eq_operators comp_rel_expr;

comp_rel_expr=
	{cond_expr} expr |
	{co}comp_rel_expr compare_rel_operators expr;

compare_eq_operators=
	{eq}assign|
	{neq}neq;

compare_rel_operators = 
	{hashtag} hashtag |
	{lt} lt |
	{gt} gt |
	{lteq} lteq |
	{gteq} gteq ;

l_value =
	{id} variable |
	{string_lit} string_lit | 
	{l_value_array} l_value_array;

l_value_array=
	{l_value_arrray}l_value l_bkt expr r_bkt;

expr =
	{factor}factor|
	{plus}expr plus factor|
	{minus}expr minus factor|
	{func_call} func_call;

factor={factor_term}term|
	{mult} factor star term |
	{slash}  factor slash term|
	{mod}  factor mod term|
    {div}  factor div term;

term =
	{term_int} integer | 
	{term_char} const_char | 
	{term_val} l_value |
	{plus_minus_exp} plus_minus term|
	{term_expr} l_par expr r_par;

plus_minus = 
	{plus} plus|
	{minus} minus;

operators = 
	{plus} plus | 
	{minus} minus | 
	{star}star |
	{div} div |
	{mod} mod ;

binary_operators = 
	{and} and |
	{or} or;

